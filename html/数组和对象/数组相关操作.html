<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>数组的相关操作</title>
  </head>

  <body>
    <div>
      <p>数组的相关操作</p>
    </div>
  </body>

  <script>
    /**
     * @desc: 数组的定义
     * new Array(length)
     */
    // 直接定义
    let arr1 = [1, 2, 3, 4, 5]

    // new Array()定义
    // 空数组 []
    let arr2 = new Array()
    // [1, 2]
    let arr3 = new Array(1, 2)

    // 一个参数，代表长度，[empty*3]
    let arr4 = new Array(3)

    /**
     * @desc: 操作方法
     */

    /**
     * @desc: Array.of
     * @params 用于将一组值转换为数组，内容为数组的每一项
     */

    // [2]
    let arr5 = Array.of(2)
    //[1, 2, 3]
    let arr6 = Array.of(1, 2, 3)

    /**
     * @desc: 实现Array.of功能
     */
    function arrayOf() {
      console.log(arguments, 888)
      return [].slice.call(arguments)
      // return [].concat(...arguments)
      // return [].slice.apply(arguments);
    }

    // [1, 3, 4, 6]
    console.log(arrayOf(1, 3, 4, 6), 999)

    /**
     * @desc: Array.from
     * 用于将类数组对象：arguments对象、DOM NodeList对象、类数组Set对象、Map对象、
     * 可遍历的对象、字符串 转为真正的数组，浅拷贝的数组实例，原对象、数组不变
     * @params Array.from(arrLike, callbackFunc, thisArg)
     */

    // 基本用法
    // ["守", "候”]
    let arr7 = Array.from('守候')
    // ['1', '2', '3', '4', '5', '1']
    let arr8 = Array.from('123451')

    // 循环
    let arr9 = Array.from(new Set([2, 3, 5]), (item, index) => {
      // 处理的是set 项 下标
      console.log(item, 111, index, 2222)
      // 4, 5, 6
      return item + 1
    })

    /**
     * @desc: 实现Array.from功能
     */
    function arrayFrom() {
      return [].slice.call(...arguments)
      // return Array.prototype.slice.call(...arguments);
    }

    // ['1', '2', '3', '1', '2']
    console.log(arrayFrom('12312'), 666)

    /**
     * @desc: reverse
     * 将数组倒序，原数组改变
     * 返回改变后数组，浅拷贝
     */
    let arr10 = [1, 2, 3, 4]
    // arr11  [4, 3, 2, 1]，arr10 [4, 3, 2, 1]
    let arr11 = arr10.reverse()

    // a10，a11同时被改变
    a11[1] = 33

    /**
     * @desc: sort(orderFunction)
     * 按指定的参数对数组进行排序,默认根据Unicode编码进行排序，默认升序
     *（n<=10使用插入排序， n>10使用快排）
     * 浅拷贝
     */
    let arr12 = [5, 2, 6, 1, 11]
    // a13 [1, 11, 2, 5, 6 ] a12 [1, 11, 2, 5, 6 ]
    let arr13 = arr12.sort()

    // 简化一下：a-b输出从小到大排序，b-a输出从大到小排序
    // [11, 6, 5, 2, 1]
    let arr14 = arr12.sort((a, b) => {
      return b - a
    })

    /**
     * @desc: slice
     * 返回从原数组中指定开始下标到结束下标之间的项组成的新数组 ,不写数字，默认全部，原数组不变
     */
    let arr15 = [1, 2, 3, 4, 5]
    //arr15 [1, 2, 3, 4, 5]  arr16 [3,4]
    let arr16 = arr15.slice(2, 4)
    // arr17 [4, 5]
    let arr17 = arr15.slice(-2)

    /**
     * @desc: join(separator)
     * 将数组的元素组起一个字符串，以separator为分隔符，省略的话则默认用逗号为分隔符,原数组不变。用于将数组转化为字符串
     */
    let arr18 = [1, 2, 3, 4, 5]
    // arr18 [1, 2, 3, 4, 5], str1 '1,2,3,4,5'
    let str1 = arr18.join()
    // str2 '1|2|3|4|5'
    let str2 = arr18.join('|')

    /**
     * @desc: concat
     * 原数组不变，返回合并后的数组
     */
    let arr19 = [1, 2]
    // arr19 [1, 2] arr20 [1, 2, 6, 7]
    let arr20 = arr19.concat(6, 7)
    // arr21 [1, 2, 6, 7]
    let arr21 = arr19.concat(...[6, 7])
    // arr22 [1, 2, 6, 7]
    let arr22 = arr19.concat([6, 7])

    // 如果传入的是数组，取的是其值。但是数组中的数组，是保留的
    // arr23 [1, 2, 6, 7, [8, 9], 10]
    let arr23 = arr19.concat([6, 7, [8, 9], 10])

    // arr24 [1, 2, 6, 7]
    let arr24 = [...arr19, ...[6, 7]]

    /**
     * @desc: fill(value, start, end)
     * 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引
     */
    let arr26 = new Array(3)
    // a26 [2, 2, 2] arr27 [2, 2, 2]
    let arr27 = arr26.fill(2)

    /**
     * @desc: push
     * 将参数添加到原数组末尾，并返回数组的长度 ，原数组改变
     */
    let arr25 = [1, 2, 3]
    // arr25 [1, 2, 3, 6, 7] len1 5
    let len1 = arr25.push(6, 7)
    // 使用数组 arr25 [1, 2, 3, 6, 7] len2 5
    let len2 = [].push.apply(arr25, [6, 7])

    /**
     * @desc: unshift
     * 将参数添加到原数组开头，并返回数组的长度。原数组改变
     */
    let arr28 = [1, 2, 3]
    // arr28 [-2, -1, 1, 2, 3] len3 5
    let len3 = arr28.unshift(-2, -1)

    /**
     * @desc: shift
     * 删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined，原数组改变
     */
    let arr29 = [1, 2, 3]
    // ar29 [2, 3] arr30 1
    let arr30 = arr29.shift()

    /**
     * @desc: pop
     * 删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined，原数组改变
     */
    let arr31 = [1, 2, 3]
    // arr31 [1, 2] arr30 3
    let arr32 = arr31.pop()

    /**
     * @desc: splice(start, deleteCount, val1, val2, ...)
     * 从start位置开始删除deleteCount项，并从该位置起插入val1,val2,...
     * 以数组形式返回删除掉的项，如果没有删除项，返回空数组 ，原数组改变
     */
    let arr33 = [1, 2, 3, 4, 5]
    // arr33 [1, 2, 7, 8, 9, 5] arr34 [3, 4]
    let arr34 = arr33.splice(2, 2, 7, 8, 9)

    // 同shift arr35 [2, 3, 4, 5] arr35 [1]
    let arr35 = arr33.splice(0, 1)

    // 同unshift arr33 [6, 1, 2, 3, 4, 5] arr36 []
    let arr36 = arr33.splice(0, 0, 6)

    // 同pop arr33 [1, 2, 3, 4] arr37 [5]
    let arr37 = arr33.splice(arr33.length - 1, 1)

    // 同push arr33 [1, 2, 3, 4, 5, 1] arr38 []
    let arr38 = arr33.splice(arr33.length - 1, 0, 1)

    /**
     * @desc: includes(searchElement, fromIndex)
     * 起始位置默认从0开始，大于数组长度返回false. 为负数从倒数开始，如果大于数组长度从0开始
     * 返回boolean
     */
    let arr39 = [1, 2, 3, 4, 5]
    // true
    let res1 = arr39.includes(2)
    // false
    let res2 = arr39.includes(2, 2)
    // false
    let res3 = arr39.includes(2, -1)
    // true
    let res4 = arr39
      .includes(2, -6)

      /**
       * @desc: indexOf(searchValue,fromIndex)
       * 查找子项在数组的位置（下标）， 查找字符在字符串中的位置
       * fromIndex可选的整数参数。规定在字符串中开始检索的位置。
       * 它的合法取值是 0 到 stringObject.length - 1。
       * 如省略该参数，则将从字符串的首字符开始检索。
       * indexOf 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。
       * 二是，它内部使用严格相等运算符（===）进行判断，这会导致对 NaN 的误判
       */
      [NaN].indexOf(NaN) // -1
      [NaN].includes(NaN) // true
    let arr40 = [1, 2, 3, 4]
    // res5 2
    let res5 = arr40.indexOf(3)
    // -1
    let res6 = arr40.indexOf(8)

    /**
     * @desc: lastIndexOf(searchValue,fromIndex)
     * 查找子项在数组最后出现的位置，默认从末尾开始查询
     */
    let arr41 = [1, 2, 3, 4, 3]
    // res7 4
    let res7 = arr41.lastIndexOf(3)

    // res8 -1
    let res8 = arr41.lastIndexOf(8)

    /**
     * @desc: at(index)
     * 接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。
     * 如果找不到指定的索引，则返回 undefined。
     */
    let arr42 = [1, 2, 3, 4]
    // 类似arr[index]  res9 2
    let res9 = arr42[1]

    // res10 4
    let res10 = arr42[-1]

    // res11 undefined
    let res11 = arr42[5]

    /**
     * @desc: Math.max(...Array) Math.min(...Array)
     * 数组求最大值，最小值
     */
    let arr43 = [1, 2, 3, 4]
    // res12 4
    let res12 = Math.max(...arr43)
    // res13 1
    let res13 = Math.min(...arr43)

    /**
     * @desc: find(callback, thisArg)
     * 用于找出第一个符合条件的数组成员。如果没找到符合条件的成员就返回undefined
     * 满足条件就返回，后面项不循环
     */
    // res14 3
    let res14 = [1, 2, 3, 4].find((item, index, array) => {
      return item > 2
    })
    // 简写 res15 undefined
    let res15 = [1, 2, 3, 4].find((item) => item > 5)

    /**
     * @desc: findLast(callback, thisArg)
     * 用于找出满足条件的最后一个数组成员。如果没找到符合条件的成员就返回undefine
     * 从数组尾部开始执行，满足条件就返回，后面项不循环
     */
    // res16 4
    let res16 = [1, 2, 3, 4].findLast((item, index, array) => {
      return item > 2
    })
    // 简写 res17 undefined
    let res17 = [1, 2, 3, 4].findLast((item) => item > 5)

    /**
     * @desc: findIndex(callback, thisArg)
     * 用于找出第一个符合条件的数组成员的索引，没有返回-1
     */
    // res18 2
    let res18 = [1, 2, 3, 4].find((item, index, array) => {
      return item > 2
    })
    // 简写 res19 -1
    let res19 = [1, 2, 3, 4].find((item) => item > 5)

    /**
     * @desc: findLastIndex(callback, thisArg)
     * 用于找出满足条件的最后一个数组成员的索引。如果没找到符合条件的成员就返回-1
     */
    // res20 3
    let res20 = [1, 2, 3, 4].findLastIndex((item, index, array) => {
      return item > 2
    })
    // 简写 res21 -1
    let res21 = [1, 2, 3, 4].findLast((item) => item > 5)

    /**
     * @desc: some(callback, thisArg)
     * 用于检测数组中是否包含满足条件的项，返回一个Boolean。没有匹配到或空数组都返回false
     */
    // res22 false
    let res22 = [1, 2, 3, 4].some((item) => {
      return item > 4
    })

    /**
     * @desc: every(callback, thisArg)
     * 用于检测数组中所有项是否都满足条件，返回一个Boolean。空数组返回true
     */
    // res23 false
    let res23 = [1, 2, 3, 4].every((item) => {
      return item > 4
    })

    /**
     * @desc: filter(callback, thisArg)
     * 返回满足满足条件的项组成的新数组（没有则返回空数组）。不会改变原数组。
     * 返回的新数组是原数组的一个浅拷贝
     */
    // res24 []
    let res24 = [1, 2, 3, 4].filter((item) => {
      return item > 4
    })

    // res25 [3, 4]
    let res25 = [1, 2, 3, 4].filter((item) => {
      return item > 2
    })

    /**
     * @desc: map(callback, thisArg)
     * 返回一个新数组，新数组的每个元素是原数组调用回调函数的返回值组成的
     */
    // res26 [4, 5, 6, 7]
    let res26 = [1, 2, 3, 4].map((item) => {
      return item + 3
    })

    /**
     * @desc: flat(depth)
     * 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回
     * depth指定要提取嵌套数组的结构深度，默认值为 1
     */
    // res27 [1, 3, 4, 5]
    let res27 = [1, 3, [4, 5]].flat()
    // res28 [1, 3, 4, 5, [6, 7]]
    let res28 = [1, 3, [4, 5, [6, 7]]].flat()
    // res29 [1, 3, 4, 5, 6, 7]
    let res29 = [1, 3, [4, 5, [6, 7]]].flat(2)

    /**
     * @desc: reduce(callback, initialValue)
     * 累加，前一项返回结果作为后一项的输入
     * callback包含(pre, currentValue, currentIndex, array)
     * 如果没有initialValue，则reduce会少运算一次，因为第一项不需要与初始值相加，第一次执行时pre为数组的第一项
     */
    // res30 10
    let res30 = [1, 2, 3, 4].reduce((prev, cur, index, array) => {
      return prev + cur
    })

    // res31 18
    let res31 = [1, 2, 3, 4].reduce((prev, cur, index, array) => {
      return prev + cur
    }, 8)
  </script>
</html>
